# 1. 운영체제 소개

## 1.1 생활 속 운영체제

<br>

📌 컴퓨터의 종류

- 범용 컴퓨터
  → 일반적인 OS(Windows, MacOS, iOS…)
- 임베디드 컴퓨터
  → 임베디드 OS

## 1.2 운영체제의 정의

<br>

📌 SW의 종류

1️⃣ 응용 프로그램 : 특정 작업을 위해 사용하는 프로그램

2️⃣ 시스템 소프트웨어 : HW와 응용 프로그램을 관리하기 위한 SW

- ex. OS, 유틸리티

<br>

📌 OS : 자원관리자

- 응용 프로그램에게 자원을 숨기고 인터페이스를 제공

## 1.3 컴퓨터 구조와 운영체제

<br>

📌 OS 실행 시기

- 컴퓨터 전원 ON
- OS 실행
- 그 이후에 응용 프로그램은 OS를 통해서만 자원 사용 가능

## 1.4 운영체제의 역할

<br>

📌 OS의 역할

1️⃣ 자원 관리 : 응용 프로그램에게 분배 및 관리

2️⃣ 자원 보호 : 악의적, 미숙한 프로그램으로부터 보호

3️⃣ HW 인터페이스 제공

4️⃣ 사용자 인터페이스 제공

## 1.5 운영체제의 목표

<br>

📌 OS 목표

| OS 역할                | OS 목표 |                                                      |
| ---------------------- | ------- | ---------------------------------------------------- |
| 자원 관리              | 효율성  | 같은 자원으로 더 많은 작업 수행                      |
| 자원 보호              | 안정성  | 프로그램, 자원 격리                                  |
| HW 인터페이스 제공     | 확장성  | 다양한 자원을 추가, 제어하기 편함                    |
| 사용자 인터페이스 제공 | 편리성  | 사용자에게 편리한 환경을 제공하면서 자원 낭비를 막음 |

# 2. 운영체제의 발전

<br>

📌 운영체제의 역사

| 시기          | 주요 기술              | 특징                                                                                                          |
| ------------- | ---------------------- | ------------------------------------------------------------------------------------------------------------- |
| 1940년대      | 없음                   | - 진공관(0과 1) 사용 <br> - 하드와이어링 방식 <br> - 수정 : 전선 재배치                                       |
| 1950년대      | 카드 리더, 라인 프린터 | - 일괄 작업 시스템 (데이터 입력, 수정 X) <br> - OS 등장 <br> - 천공 카드 <br> - 수정 : 새로운 카드            |
| 1960년대 초반 | 키보드, 모니터         | - 대화형 시스템 (데이터 입력 및 오류 검출) <br> - 응용 프로그램                                               |
| 1960년대 후반 | C 언어                 | - 멀티프로그래밍 기술 개발 <br> - 시분할 시스템                                                               |
| 1970년대      | PC                     | - 개인용 컴퓨터의 등장 <br> - 분산 시스템 (네트워크) <br> - 네트워크 안 컴퓨터의 역할 동일 → 에러 처리 어려움 |
| 1990년대      | 웹                     | - 클라이언트/서버 시스템 (이중 구조) <br> - 서버 과부하                                                       |
| 2000년대      | 스마트폰               | - P2P 시스템 (메신저, 파일 공유) → 서버 과부하 해결 <br> - 클라우드 컴퓨팅 <br> - 사물 인터넷                 |

# 3. 운영체제의 구성

## 3.1 커널과 인터페이스

<br>

📌 OS의 구성

- 커널(핵심 기능) + 인터페이스(커널-응용 프로그램)

## 3.2 시스템 호출과 디바이스 드라이버

> 커널 내부에 시스템 콜과 드라이버가 있음

<br>

📌 시스템 콜

- 응용 프로그램의 자원 사용을 위한 인터페이스

<br>

📌 디바이스 드라이버

- 커널과 HW의 인터페이스

## 3.3 커널의 역할과 종류

<br>

📌 커널의 역할

1️⃣ 프로세스 관리 : CPU 분배 및 작업 환경 제공

2️⃣ 메모리 관리 : 프로세스에 작업 공간 배치 / 실제 메모리보다 큰 가상 메모리 제공

3️⃣ 파일 시스템 관리

4️⃣ 입출력 관리

5️⃣ 프로세스 간 통신 관리

<br>

📌 커널의 종류

1️⃣ 단일형 구조 커널 : 모듈 구분 없음

- 장점 : 통신 비용 ↓
- 단점 : 에러 처리 어려움 / 상호 의존성 ↑ / 이식성 ↓

2️⃣ 계층형 구조 커널 : 비슷한 기능 모듈을 묶음

- 장점 : 에러 처리 쉬움 / 상호 의존성 ↓
- 윈도우 OS

3️⃣ 마이크로 구조 커널 : 기본적인 기능만 제공하고 모듈을 세분화

- 장점 : 상호 의존성 ↓ / 이식성 ↑
- iOS

## 3.4 가상머신

<br>

📌 가상 머신은 언어 호환성 문제를 해결

- OS 위에 가상 머신을 만들고 그 위에서 응용 프로그램이 동작
- 장점 : 호환성 / 단점 : 속도 ↓

# 4. 운영체제의 더 깊은 역사

## 4.1 유닉스와 리눅스

### 유닉스의 개발과 확산

<br>

📌 유닉스

- 단순한 구조(프로그램 실행에만 중점을 두고 개발됨)
- 이식성 ↑(C언어)

### 다양한 유닉스 버전의 개발

<br>

📌 BSD(Berkeley Software Distribution) 유닉스

- 특징 : 네트워킹 소프트웨어

<br>

📌 System V 유닉스

- 기존 유닉스

<br>

📌 마하 유닉스

- 마이크로 구조 커널, 매킨토시

### GNU와 유닉스

<br>

📌 GNU(GNU is Not Unix) 프로젝트

- 오픈 소스 주장

<br>

📌 리눅스

- GNU의 유닉스
- 오픈소스 → ∴ 안정성 ↑

## 4.2 매킨토시와 스티브 잡스

<br>

📌 애플 II

- 일체형 모델, 개인용 컴퓨터의 시초 → 대중화
- MacOS

## 4.3 윈도우 운영체제

<br>

📌 IBM 컴퓨터는 애플과 달리 오픈 정책 → 인기 ↑

- 이때 운영체제 : MS-DOS

<br>

📌 윈도우 OS의 단점

- 안정성 ↓
- 무거움

## 4.4 모바일 OS

<br>

📌 스마트폰의 등장으로 윈도우 인기 ↓

📌 모바일 OS

- iOS, 안드로이드

# Chapter 04 : CPU 스케줄링

# 1. 스케줄링의 개요

## 1.1 레스토랑 관리자의 스케줄링

📌 CPU 스케줄러 : 프로세스의 모든 상태 변화를 조정함

📌 레스토랑 관리자의 스케줄링

- 예약 관리, 좌석 관리
- 주문 관리
- 조리 순서 관리
- 손님 요청 관리

## 1.2 CPU 스케줄링

📌 CPU 스케줄러는 규모에 따라 관리의 범주를 나누어 스케줄링

- 고수준, 중간 수준, 저수준 스케줄링

📌 고수준 스케줄링(high level, long-term, job, admission scheduling)

- 시스템 내의 전체 작업 수를 조절하는 것
  → 작업 승인 여부를 결정하는 것이라서, 승인 스케줄링(admission) 이라고도 함
- 고수준 스케줄링에 따라 시스템 내에서 동시 실행 가능한 프로세스의 수가 정해짐

📌 저수준 스케줄링(low level, short-term scheduling)

- 프로세스의 상태를 결정하는 것

📌 중간 수준 스케줄링(middle level scheduling)

- 활성화된 프로세스를 시스템의 부하에 따라 조절하는 것
- 중지(suspend)와 활성화(active)로 전체 프로세스 수를 조절
  → 중지가 되면 프로세스는 보류 상태가 됨

## 1.3 스케줄링의 목적

📌 스케줄링의 목적

- 공평성 : 모든 프로세스가 자원을 공평하게 배분 받아야함
- 효율성 : 시트템 자원이 유휴 시간이 없도록
- 안정성 : 우선순위를 사용해서 중요 프로세스가 먼저 동작하도록
- 확장성 : 프로세스가 증가해도 시스템이 안정적으로 동작하도록
- 반응 시간 보장 : 적절한 시간 안에 프로세스의 요구에 반응하도록
- 무한 연기 방지 : 특정 프로세스의 작업이 무한 연기되지 않도록

📌 모든 프로세스가 공평하게 자원을 배분 받아야하지만, 시스템의 안정성과 효율성을 높이기 위해 우선순위가 바뀔 수 있음

# 2. 스케줄링 시 고려 사항

## 2.1 선점형 스케줄링과 비선점형 스케줄링

📌 선점형 스케줄링, 비선점형 스케줄링

- 선점형 스케줄링(preemptive scheduling)
  - 어떤 프로세스가 CPU를 받아서 실행 중이라도 OS가 CPU를 빼앗을 수 `있는` 스케줄링
- 비선점형 스케줄링(non-preemptive scheduling)
  - 어떤 프로세스가 CPU를 받아서 실행 중이라도 OS가 CPU를 빼앗을 수 `없는` 스케줄링

## 2.2 프로세스 우선순위

📌 우선순위가 있다는 것 == 프로세스의 중요도가 다르다는 것

📌 우선순위 ↑ ⇒ CPU를 더 먼저, 더 자주, 더 오래 차지함

- 우선순위의 번호가 낮을수록 우선순위가 높은 것

## 2.3 CPU 집중 프로세스와 입출력 집중 프로세스

✅ 정리

- 프로세스에서 실제 작업이 일어나는 상태 : 실행 상태, 대기 상태
- 실행 상태 : CPU를 받아서 작업 실행
- 대기 상태 : 입출력을 요청해서 입출력이 완료되기까지 기다리는 상태

---

- CPU 버스트(CPU burst) : CPU를 할당받아 실행하는 작업
- IO 버스트(IO burst) : 입출력 작업

---

- CPU 집중 프로세스(CPU bound process)
  - CPU 버스트가 많음
- 입출력 집중 프로세스(IO bound process)
  - IO 버스트가 많음

📌 CPU 집중 프로세스와 입출력 집중 프로세스 중 입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적

→ ∵ 입출력 요청만 보내고 대기 상태로 가서 다른 프로세스가 CPU를 사용할 수 있으므로

- 따라서 스케줄링할 때 입출력 집중 프로세스의 우선순위를 CPU 집중 프로세스보다 높이면 시스템 효율 ↑

📌 사이클 훔치기(cycle stealing)

입출력 집중 프로세스가 CPU 집중 프로세스보다 먼저 실행 상태로 들어가는 것

## 2.4 전면 프로세스와 후면 프로세스

📌 전면 프로세스 : 사용자와 상호작용하는 프로세스(상호작용 프로세스)

- 현재 입출력을 사용하고 있는 프로세스

📌 후면 프로세스 : 사용자와 상호작용이 없는 프로세스

## 2.5 정리

📌 CPU 스케줄링 시 고려사항

| **우선순위 높음**    | **우선순위 낮음**  |
| -------------------- | ------------------ |
| 커널 프로세스        | 일반 프로세스      |
| 전면 프로세스        | 후면 프로세스      |
| 대화형 프로세스      | 일괄 처리 프로세스 |
| 입출력 집중 프로세스 | CPU 집중 프로세스  |

📌 프로세스 우선순위 배정 기준

- 커널/일반 프로세스, 전면/후면 프로세스
  → ∵ 구분이 명확하므로
- 나머지 기준은 구분이 명확하지 않은 경우가 있어 우선순위를 고려하기 어려울 수 있음

# 3. 다중 큐

## 3.1 준비 상태의 다중 큐

📌 다중 큐의 필요성

- 매번 우선 순위가 높은 PCB를 찾는 것은 비효율적
- CPU 스케줄러는 PCB에 있는 중요도가 가장 높은 프로세스에게 CPU 할당
- 우선순위에 따라 여러 큐를 만들어두면 찾지 않아도 돼서 효율적

📌 프로세스의 우선순위를 배정하는 방식

1. 고정 우선순위 방식(static priority)
   - 프로세스가 작업하는 동안 우선순위가 변하지 않음
   - 시스템의 변화에 대응하기 어려워 작업 효율이 떨어짐
2. 변동 우선순위 방식(dynamic priority)
   - 우선순위가 작업 중간에 변함
   - 구현이 어렵지만 시스템 효율성 ↑

## 3.2 대기 상태의 다중 큐

📌 대기 상태 : 입출력이 완료되기를 기다리는 프로세스

📌 같은 입출력을 요구한 프로세스끼리 모아놓음 → 시스템 효율 ↑

→ ∵ 인터럽트가 발생한 경우 해당 프로세스를 찾기 위해 모든 대기 상태의 프로세스를 찾는 것은 비효율적

📌 준비 상태 다중 큐 vs 대기 상태 다중 큐

- 준비 큐 : 한 번에 1개의 프로세스를 꺼내서 CPU 할당
- 대기 큐 : 여러 개 PCB를 동시에 꺼내서 준비 상태로 옮김
  → ∵ 여러 인터럽트를 한 번에 처리해서

📌 인터럽트 벡터(interrupt vector)

- 동시에 끝나는 인터럽트를 처리하기 위해 사용하는 자료구조
- 완료된 입출력 정보와 처리 방법이 담겨져 있음

# 4. 스케줄링 알고리즘

## 4.1 스케줄링 알고리즘의 선택 기준

📌 스케줄링 알고리즘의 성능을 비교할 때 주로 평균 대기 시간을 봄

- `평균 대기 시간 = 모든 프로세스의 대기 시간 / 프로세스의 수`
- 대기 시간 : 프로세스가 생성된 후 실행되기 전까지 대기하는 시간

### 1. FCFS (First Come First Served) 스케줄링

- 방식: 도착 순서대로 CPU를 할당하는 비선점형 방식 (FIFO)
- 특징:
  - 실행 중인 프로세스가 끝나야 다음 프로세스가 실행됨
  - 우선순위 개념 없이 단순한 선입선출 방식
- 성능:
  - 평균 대기 시간 = (총 대기 시간) / (프로세스 개수)
  - 처리 시간이 긴 프로세스가 CPU를 독점하면 다른 프로세스가 오래 기다리는 콘보이 효과(Convoy Effect) 발생
  - 입출력 요청이 많은 시스템에서 CPU 사용률이 떨어질 가능성 있음

---

### 2. SJF (Shortest Job First) 스케줄링

- 방식: 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식
- 특징:
  - 작은 작업이 빠르게 처리되어 평균 대기 시간이 줄어듦
  - 콘보이 효과를 완화하여 시스템의 효율성을 높임
- 문제점:
  - 프로세스의 종료 시간을 미리 예측하기 어려움
  - 작업 시간이 짧은 프로세스가 계속 들어오면 긴 작업이 연기되는 아사(Starvation) 현상 발생
  - 해결책: 에이징(Aging) 기법을 활용해 오랫동안 대기한 프로세스의 우선순위를 높임

---

### 3. **HRN (Highest Response Ratio Next) 스케줄링**

- 방식: 대기 시간과 작업 시간을 모두 고려한 비선점형 방식
- 우선순위 계산:
- **특징**:
  - 대기 시간이 길면 우선순위가 증가하여 아사 현상이 완화됨
  - SJF의 효율성을 유지하면서 공정성을 보완
- **문제점**:
  - 여전히 공평성 문제가 남아 있어 널리 사용되지는 않음

---

### 4. **라운드 로빈 (Round Robin, RR) 스케줄링**

- 방식: 모든 프로세스가 타임 슬라이스만큼 CPU를 사용한 후 큐의 맨 뒤로 이동하는 선점형 방식
- 특징:
  - FCFS와 유사하지만, 특정 시간 동안만 CPU를 점유할 수 있음
  - 모든 프로세스가 공평하게 CPU를 사용하므로 대화형 시스템에 적합
- **문제점**:
  - 문맥 교환(Context Switching) 비용이 추가됨 → 타임 슬라이스가 너무 작으면 오버헤드 증가
  - 타임 슬라이스 크기에 따라 성능이 달라짐 → 적절한 값 설정이 중요

---

### 5. **SRT (Shortest Remaining Time) 스케줄링**

- **방식**: SJF의 선점형 버전으로, 남은 작업 시간이 가장 짧은 프로세스에 CPU를 할당
- **특징**:
  - 실행 중인 프로세스보다 더 짧은 작업이 들어오면 CPU를 빼앗김
  - 평균 대기 시간이 짧음
- **문제점**:
  - 계속해서 남은 작업 시간을 계산해야 함 → 추가적인 연산 비용 발생
  - SJF와 마찬가지로 아사 현상이 발생할 수 있음

---

### 6. **우선순위 스케줄링 (Priority Scheduling)**

- 방식: 각 프로세스가 우선순위(priority) 를 가지며, 우선순위가 높은 프로세스부터 CPU를 할당
- **특징**:
  - 비선점형 또는 선점형으로 구현 가능
  - 중요한 작업을 먼저 실행할 수 있음
- **문제점**:
  - 아사 현상 발생 가능 → 에이징(Aging) 기법으로 완화
  - 우선순위를 매기는 기준이 명확하지 않으면 시스템 효율성이 저하될 수 있음

---

### 7. **다단계 큐 (Multi-Level Queue, MLQ) 스케줄링**

- 방식: 프로세스를 여러 개의 준비 큐(우선순위별)로 나누어 관리
- 특징:
  - 각 큐는 독립적으로 스케줄링됨 (예: 상위 큐는 RR, 하위 큐는 FCFS)
  - 우선순위가 높은 큐의 프로세스가 모두 끝나야 다음 큐가 실행됨
- 문제점:
  - 낮은 우선순위 프로세스가 계속 대기해야 하는 문제 발생

---

### 8. **다단계 피드백 큐 (Multi-Level Feedback Queue, MLMQ) 스케줄링**

- **방식**: 다단계 큐 스케줄링의 문제(우선순위 고정)를 개선한 방식
- **특징**:
  - CPU를 사용한 프로세스의 우선순위를 점점 낮춤
  - 우선순위가 낮아질수록 타임 슬라이스가 커짐 → 긴 작업도 처리 가능
  - 우선순위에 따라 **변동 우선순위 알고리즘**을 적용하여 유동적으로 스케줄링 가능
- **장점**:
  - 현대 운영체제에서 가장 많이 사용됨 (예: UNIX 운영체제의 CPU 스케줄링)

---

### **정리**

| 스케줄링 방식 | 선점형 여부 | 주요 특징                        | 단점                             |
| ------------- | ----------- | -------------------------------- | -------------------------------- |
| **FCFS**      | ❌          | 단순한 선입선출 방식             | 콘보이 효과 발생                 |
| **SJF**       | ❌          | 짧은 작업 우선                   | 종료 시간 예측 어려움, 아사 발생 |
| **HRN**       | ❌          | 대기 시간 고려하여 우선순위 결정 | 구현 복잡                        |
| **RR**        | ✅          | 타임 슬라이스 기반 순환 실행     | 문맥 교환 비용 증가              |
| **SRT**       | ✅          | SJF의 선점형 버전                | 남은 시간 계산 비용, 아사 발생   |
| **우선순위**  | ✅/❌       | 우선순위 기반 스케줄링           | 우선순위 지정 어려움, 아사 발생  |
| **MLQ**       | ✅          | 여러 개의 준비 큐 운영           | 낮은 우선순위 프로세스 실행 지연 |
| **MLMQ**      | ✅          | 다단계 큐 + 우선순위 동적 조정   | 시스템 설계 복잡                 |

MLMQ(다단계 피드백 큐)가 현대 운영체제에서 가장 널리 사용되는 스케줄링 방식

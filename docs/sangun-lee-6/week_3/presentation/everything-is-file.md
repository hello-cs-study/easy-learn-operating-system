# 모든 것은 파일이다 (Everything is a file)

유닉스는 프로세스 간 통신(IPC)을 포함한 대부분의 시스템 자원을 '파일'이라는 개념으로 추상화하여 일관되고 단순하게 관리할 수 있도록 설계되었습니다.

## 0. 💡 프로세스 간 통신(IPC)과 파일 추상화

| IPC 방식       | 사용하는 시스템 콜             | 설명                                             | fd의 대상                                                        |
| -------------- | ------------------------------ | ------------------------------------------------ | ---------------------------------------------------------------- |
| 파일 IPC       | `open()`, `read()`, `write()`  | 직접 파일을 이용한 통신                          | 디스크의 파일 inode, 데이터 블록                                 |
| 공유메모리 IPC | `mmap()`                       | 메모리를 파일처럼 매핑(익명 또는 파일 기반 가능) | 가상 메모리 영역 (페이지 테이블을 통한 매핑)                     |
| 파이프 IPC     | `pipe()`, `read()`, `write()`  | 파일 디스크립터(fd)를 통해 데이터 전송           | 커널의 파이프 버퍼                                               |
| 소켓 IPC       | `socket()`, `send()`, `recv()` | 소켓을 파일 디스크립터(fd)로 관리                | 커널의 소켓 버퍼, 네트워크 스택 (`struct socket`, `struct sock`) |

**📌 참고 : 공유 메모리 IPC에서의 `mmap()`**

- `mmap()`으로 파일과 연결된 공유 메모리를 만들 수도 있지만, 파일 없이 메모리만 할당하는 익명 매핑도 가능
- 파일 기반 매핑: `shm_open()`을 통해 파일 시스템(/dev/shm 등)의 파일을 메모리에 매핑
- 익명 매핑: 운영체제가 제공하는 메모리 공간을 여러 프로세스가 공유

## **1. 개념 이해**

📌 Unix 계열 OS에서 말하는 `모든 것은 파일이다`의 의미

- 실제 파일이 아니라 시스템의 자원이 파일과 유사한 방식으로 동작한다는 것
- 파일뿐만 아니라 입출력 장치, 네트워크 소켓, 프로세스 간 통신(IPC) 등도 파일과 같은 방식으로 사용됨

📌 예시 : 터미널 입출력, 네트워크 소켓

- 터미널 입력 (표준 입력, stdin, 파일 디스크립터 0)
  → 사용자가 터미널에서 입력하면 표준 입력 파일과 같은 방식으로 처리
- 터미널 출력 (표준 출력, stdout, 파일 디스크립터 1)
  → `echo "Hello"` 같은 명령을 실행하면 표준 출력 파일에 데이터를 쓰는 것과 같은 방식으로 처리
- 네트워크 소켓
  → 서버와의 통신도 읽기/쓰기 가능한 파일처럼 동작

## 2. **"모든 것을 파일로” 취급하는 이유**

> Unix 철학에서 *모든 것을 파일처럼 다루는 것*은 설계상의 이점이 많다.

1️⃣ 일관된 인터페이스 제공

- 동일한 시스템 호출(API)로 다양한 자원을 다룰 수 있음
  → ex. `write()`는 표준 출력, 파일, 소켓 등 다양한 자원에 사용할 수 있음

2️⃣ 파일 디스크립터(`fd`) 활용

- Unix에서 파일을 열면 파일 디스크립터(file descriptor) 라는 고유한 숫자가 할당됨
- 예시
  - 표준 입력: `0`
  - 표준 출력: `1`
  - 파일, 소켓, 프로세스 간 통신 등도 파일 디스크립터를 사용

## 3. **예제 코드**

1. `write()`를 이용한 표준 출력

- C 언어에서 `write()` 시스템 호출을 사용하면 파일이든 터미널 출력이든 동일한 방식으로 데이터 출력

```c
#include <unistd.h>

int main() {
    write(1, "Hello, world!\n", 14); // 표준 출력 (파일 디스크립터 1)
    return 0;
}
```

2. 파일에 데이터 쓰기

아래 코드에서는 `write()`를 이용해 파일에 데이터를 기록

```c
#include <fcntl.h>
#include <unistd.h>

int main() {
    // 파일 열기 (쓰기 전용, 없으면 생성, 기존 내용 삭제)
    int fd = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);

    // 파일에 쓰기
    write(fd, "Hello, World!\n", 14);

    // 파일 닫기
    close(fd);

    return 0;
}
```

3. 네트워크 소켓을 이용한 데이터 송수신

파일과 마찬가지로, 네트워크 소켓도 읽기/쓰기 가능한 파일처럼 동작

```c
void send_http_request(int client_socket, const char *host, const char *path) {
    char request[1024];
    snprintf(request, sizeof(request), "GET %s HTTP/1.1\r\nHost: %s\r\n\r\n", path, host);

    // 네트워크 소켓에 데이터 쓰기 (파일처럼 동작)
    write(client_socket, request, strlen(request));
}
```

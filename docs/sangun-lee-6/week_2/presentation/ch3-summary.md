# Chapter 03 : 프로세스와 스레드

# 1. 프로세스의 개요

## 1.1 프로세스의 개념

📌 프로그램 vs 프로세스

| 프로그램 | 저장장치에 저장된 정적인 상태           |
| -------- | --------------------------------------- |
| 프로세스 | 실행을 위해 메모리에 올라온 동적인 상태 |

## 1.2 요리사 모형의 비유

## 1.3 프로그램에서 프로세스로의 전환

📌 프로세스와 프로그램의 관계

- 프로세스 = 프로그램 + PCB

📌 PCB에 있는 정보 중 대표적인 정보

1️⃣ 프로세스 구분자(PID)

2️⃣ 프로세스의 메모리 위치 정보, 경계 레지스터, 한계 레지스터

3️⃣ 각종 중간값(레지스터 값)

## 1.4 프로세스의 상태

📌 프로세스의 활성 상태(process active status)

1️⃣ 생성 상태(create status) : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태

2️⃣ 준비 상태(ready status) : 프로세스가 CPU를 얻을 때까지 기다리는 상태

- 준비 → 실행 상태 by CPU 스케줄러(디스패치)

3️⃣ 실행 상태(running status) : 프로세스가 CPU를 얻어 실제 작업을 수행하는 상태

4️⃣ 완료 상태(terminate status) : 프로세스가 작업을 끝낸 상태

5️⃣ 대기 상태(blocking status, wait status) : 프로세스가 요청한 입출력 작업이 완료될 때까지 기다리는 상태

- 입출력 완료 시 인터럽트 발생 → 준비 상태로 이동

📌 프로세스의 비활성 상태

1️⃣ 휴식 상태(pause status) : 프로세스가 작업을 일시적으로 쉬고 있는 상태

→ 데이터와 PCB가 메모리에 유지됨

2️⃣ 보류 상태(suspend status) : 프로세스가 메모리에서 쫒겨나서 스왑 영역에 있는 상태

# 2. 프로세스 제어 블록과 문맥 교환

## 2.1 프로세스 제어 블록

📌 PCB

- 프로세스를 실행하는 데 필요한 정보를 보관하는 자료구조
- 프로세스마다 고유한 PCB가 있음

📌 PCB의 구성

1️⃣ 포인터(PCB 끼리 연결해서 큐를 구현할 때 사용)

2️⃣ 프로세스 상태

3️⃣ 프로세스 구분자(PID)

4️⃣ 프로그램 카운터(PC)

5️⃣ 프로세스 우선순위

6️⃣ 각종 레지스터 정보

7️⃣ 메모리 관리 정보

8️⃣ 할당된 자원 정보(IO 등)

9️⃣ 계정 정보

1️⃣0️⃣ 부모 프로세스의 PID, 자식 프로세스의 PID

## 2.2 문맥 교환

📌 문맥 교환(context switching)

- 두 프로세스의 PCB를 교환하는 작업

📌 문맥 교환의 절차

- 예시 : 실행 상태의 프로세스 P1, 준비 상태의 프로세스 P2

1. P1 : 타임 아웃되어 PCB에 현재까지 작업 결과 저장
2. P1 : 준비 상태로 이동
3. P2 : 실행 상태로 이동
4. CPU : P2의 PCB로 값이 채워짐, P2 실행

📌 문맥 교환과 타임 슬라이스 크기

- 타임 슬라이스 ↑ ⇒ 작업이 끊겨 보임
- 타임 슬리이스 ↓ ⇒ 문맥 교환에 자원 낭비
- ∴ 타임 슬라이스를 적절한 크기로 설정해야함

# 3. 프로세스의 연산

## 3.1 프로세스의 구조

📌 프로세스 구조

- 코드 영역, 데이터 영역, 스택 영역

📌 코드 영역(code area, text area)

- 저장 : 프로그램의 코드
- 읽기 전용

📌 데이터 영역(data area)

- 저장 : 코드가 실행되면서 사용하는 데이터
- 읽기, 쓰기 가능

📌 스택 영역(stack area)

- 저장 : OS가 프로세스를 실행하기 위해 부수적으로 필요한 데이터

## 3.2 프로세스의 생성과 복사

📌 fork() 시스템 콜

- 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수
- 프로세스를 복제하면 기존 프로세스는 부모 프로세스가 되고, 복제로 생성된 프로세스는 자식 프로세스가 됨

📌 fork()의 동작 과정

- 자식 프로세스는 부모 프로세스와 거의 동일한 상태
- PCB 중 일부가 변경됨
  - PID
  - 메모리 관련 정보
  - PPID, CPID 값
    → 자식 프로세스는 CPID가 없으므로 -1이 됨

📌 fork()의 장점

- 프로세스 생성 속도가 빠름
  - 디스크로부터 프로그램을 가져오지 않고 메모리에서 복사하므로
- 추가 작업 없이 자원 상속 가능
  - 부모의 자원을 자식에게 바로 상속 가능
- 시스템 관리를 효율적으로 할 수 있음
  - 자식 프로세스가 완료 상태가 되면 부모 프로세스가 이를 정리함

## 3.3 프로세스의 전환

📌 exec() 시스템 콜

- 기존 프로세스를 새로운 프로세스로 전환하는 함수
- 이는 프로세스의 구조를 재활용하기 위함

📌 프로세스 구조를 재활용하는 이유

- 새로운 프로세스를 생성하려면 : PCB 생성, 메모리 확보, GC를 위한 작업
- exec()를 사용하면 만들어진 PCB, 메모리를 그대로 사용할 수 있어서 편리함
  → 새로운 코드 영역만 가져오면 됨

📌 exec() 동작 과정

- 코드 영역 : 내용이 지워지고 새로운 코드로 바뀜
- 데이터 영역 : 새로운 변수로 채워짐
- 스택 영역 : 초기화됨
- PCB : PID, PPID, CPID, 메모리 정보는 그대로지만 레지스터, 파일 정보는 초기화

## 3.4 프로세스의 계층 구조

📌 유닉스 프로세스 계층 구조

- 부팅되면 커널이 실행됨 → `init` 프로세스가 전체 프로세스의 출발점이 됨
- 효율적인 관리를 위해 나머지 자식을 `init` 프로세스의 자식으로 만듦

📌 프로세스 계층 구조의 장점 1️⃣ : 동시에 여러 작업을 처리

- 연속적인 작업을 처리할 때 프로세스를 새로 생성하는 것보다 `fork()` 후 `exec()`를 사용하면 자원 효율적

📌 프로세스 계층 구조의 장점 2️⃣ : 종료된 프로세스 자원 회수에 유용

- OS가 모든 프로세스의 자원을 회수하기보단
- 각 부모 프로세스가 자식 프로세스의 자원을 회수하는 것이 효율적

📌 고아 프로세스와 좀비 프로세스

- 부모는 자원 회수를 위해 자식이 끝날 때까지 기다려야함
- 고아 프로세스 : 부모 프로세스가 먼저 종료된 프로세스
- 좀비 프로세스 : 종료 후에도 부모가 뒤처리를 하지 않은 프로세스

# 4. 스레드

## 4.1 스레드의 개념

📌 프로세스 : 스레드 = 요리 작업 전체 : 각 조리 단계

📌 프로세스 : OS 입장에서 작업 단위 / 스레드 : CPU 입장에서 작업 단위

📌 스레드 == 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위

## 4.2 멀티스레드의 구조와 예

📌 fork() 시스템 콜의 단점

- 여러 프로세스를 만들어서 여러 작업을 진행하지만
- 코드 영역과 데이터 영역, PCB의 일부가 메모리에 중복
- 스레드는 이런 낭비 요소를 제거하기 위해 사용됨
  → 코드, 데이터 등을 공유하며 하나의 프로세스 안에서 일함

📌 프로세스 영역은 정적 영역과 동적 영역으로 구분됨

- 정적 영역 : 프로세스가 실행되는 동안 바뀌지 않는 영역
- 동적 영역 : 스레드가 작업을 하면서 값이 변하는 영역
  → ex. 레지스터 값, 스탭, 힙

📌 멀티스레드는 정적 영역을 공유해서 멀티태스킹의 메모리 낭비를 줄임

## 4.3 멀티스레드의 장단점

📌 멀티스레드의 장점

- 응답성 ↑ : 한 스레드의 입출력으로 인해 작업이 안돼도 다른 스레드가 작업을 진행 가능
- 자원 공유 : 스레드끼리 같은 자원을 공유해서 작업 효율 ↑
- 효율성 ↑ : 자원의 중복을 막음
- 다중 CPU 지원 시 성능 ↑ : 다중 CPU가 있을 때 멀티스레드를 사용하면 성능 ↑

📌 멀티스레드의 단점

- 자원을 공유 → ∴ 한 스레드에 문제가 생기면 전체 프로세스에 영향

## 4.4 멀티스레드 모델

📌 스레드도 커널 스레드(kernel-level thread)와 사용자 스레드(user-level thread)로 나뉨

- 사용자 스레드가 커널 스레드를 사용하려면 시스템 콜을 통해야함
- 사용자-커널 스레드의 대응 방식 모델
  - 1 to N, 1 to 1, M to N 모델

📌 사용자 스레드(1 to N 모델)

📌 커널 스레드(1 to 1 모델)

📌 멀티레벨 스레드(M to N 모델)

# 5. 동적 할당 영역과 시스템 호출

## 5.1 프로세스의 동적 할당 영역

📌 정적 할당 영역

- 프로세스가 실행되는 동안 변하지 않음
- 코드 영역, 데이터 영역
  → 포인터를 제외한 일반적인 변수는 선언할 때 그 크기가 결정됨

📌 동적 할당 영역

- 스택, 힙 영역

📌 함수 호출 시 스택의 사용

- 함수 종료 시 복귀 주소 저장
- 지역 변수 저장
  → 변수 사용 범위에 영향을 미치는 영역(scope)을 구현

📌 스택은 프로세스를 작동하기 위해 커널이 유지하는 자료구조

- 스택은 스레드가 동작하는 동안 추가/삭제되는 동적 할당 영역

📌 힙 영역

- 일부 데이터는 프로그램이 실행되는 동안 할당됨
  → ex. `malloc()`

## 5.2 exit()와 wait() 시스템 호출

📌 exit() 시스템 콜

- 작업의 종료를 알려주는 시스템 콜
- exit()으로 부모 프로세스는 자식의 자원을 빨리 회수 가능

📌 wait() 시스템 콜

- 부모 프로세스가 먼저 종료되어 고아 프로세스가 되는 것을 막기 위해 wait() 시스템 콜을 사용

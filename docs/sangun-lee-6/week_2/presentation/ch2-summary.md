# Chapter 02 : 컴퓨터의 구조와 성능 향상

# 1. 컴퓨터의 기본 구성

## 1.1 HW의 구성

📌 컴퓨터의 구성

- CPU, 메인메모리, 입출력 장치, 메인메모리, 저장장치

📌 CPU와 메모리

- CPU : 명령어를 해석해서 실행하는 장치
- 메모리 : 작업에 필요한 프로그램과 데이터를 저장하는 장소
  - 바이트 단위로 분할되어 있음
  - 주소로 구분

📌 메모리와 저장 장치

- 메모리 : 전자의 이동으로 데이터를 처리 → ∴ 속도가 빠름
- 저장장치 : 기계의 이동으로 데이터를 처리 → ∴ 속도가 느림
- 저장장치의 장점
  1. 저장 용량에 비해 가격이 저렴
  2. 전원에 관계 없이 데이터를 반영구적으로 저장

📌 메인보드(main board)

- CPU와 메모리 등 다양한 부품을 연결하고 전원을 공급해주는 판
- 메인보드의 버스 : 일정한 경로를 따라 각 장치에 데이터를 전송하는 역할
- 메인보드에는 각종 부품을 연결할 수 있는 단자가 있음

📌 버스(bus)

- 데이터가 지나다니는 통로

## 1.2 폰노이만 구조

📌 폰노이만 구조

- CPU, 메모리, 입출력장치, 메모리, 저장장치가 버스로 연결된 구조

📌 폰노이만 구조 이전의 프로그래밍

- 하드와이어링 형태라서 다른 용도로 사용하려면 전선을 바꿔야했음
- 그러나 폰노이만 구조에서는 메모리를 이용
  → ∴ HW는 바꾸지 않고 프로그램만 바꾸는 방식

📌 폰노이만 구조의 중요한 특징 : 모든 프로그램은 메모리에 올라와야 실행 가능

- OS도 메모리에 올라와야 실행 가능

## 1.3 요리사 모형

📌 폰노이만 구조의 이해를 돕기 위한 요리사 모형

| CPU                | 요리사         |
| ------------------ | -------------- |
| 메모리             | 도마           |
| 저장장치           | 재료 보관 창고 |
| OS의 프로세스 관리 | 요리 방법 결정 |
| OS의 메모리 관리   | 도마 정리      |
| OS의 저장장치 관리 | 보관 창고 정리 |

## 1.4 기초 용어 정리

### 클록과 헤르츠

📌 클록(clock)

- 컴퓨터에서 일정한 박자
- 컴퓨터에서 작업은 일정한 박자에 맞춰 진행
  → ex. 클록 한 번에 CPU의 덧셈, 메모리에서 데이터 가져오기/저장

📌 펄스(pulse), 클록 틱(clock tick)

- 클록에 의해 일정 간격으로 만들어지는 개별 전기 신호
- 펄스 집합 ≒ 클록

📌 헤르츠(hertz) [Hz]

- CPU 성능을 나타내는 단위
- 1초에 펄스가 1번 나타나면 1 헤르츠
  → 3GHz CPU : 1초에 30억 번의 작업이 가능한 CPU

### 시스템 버스와 CPU 버스

📌 시스템 버스(system bus)

- 메모리와 주변장치를 연결하는 버스

📌 CPU 내부 버스

- CPU 내부에 있는 장치를 연결하는 버스
- 속도 : CPU 클록과 같음, 시스템 버스보다 빠름

### 프로그래밍과 언어

📌 컴파일(compile)

- 고급언어를 기계어로 번역하는 과정
- 고급언어로 만든 소스코드(source code)는 컴퓨터가 이해할 수 없음
  → ∴ 이를 기계어로 번역해줘야함
- 소스코드 → [ 컴파일러 ] → 실행 파일(기계어)

📌 컴파일러(compiler)

- 컴파일을 담당하는 프로그램
- 실행 파일을 생성

📌 인터프리터(interpreter)

- 소스코드를 한 번에 한 문장씩 기계어로 번역해서 실행
- 컴파일러와 달리 실행 파일을 만들지 않음
- 단점
  - 위에서부터 한 줄씩 실행되므로 코드의 잘못된 부분을 파악하기 어려움
  - 반복되는 작업을 하나로 합치기 어려움

# 2. CPU와 메모리

## 2.1 CPU의 구성과 동작

### CPU의 기본 구성

📌 CPU : 명령어를 해석해서 실행하는 장치

- 구성
  - 산술논리 연산장치(ALU) : 산술연산, 논리연산
  - 제어장치 : 작업 지시
  - 레지스터 : 데이터 임시 보관

### CPU의 명령어 처리 과정

📌 CPU는 기계어만 인식함

- ∴ 프로그램을 실행하려면 컴파일해서 기계어로 번역해야함

### 레지스터의 종류

📌  레지스터 : 데이터 레지스터, 주소 레지스터

📌 사용자 가시 레지스터(user-visible register)

- 사용자 프로그램에 의해 변경되는 레지스터
  → CPU가 데이터를 메모리에서 가져와서 연산할 때 사용됨
- 종류
  1. 데이터 레지스터(= 일반, 범용 레지스터) : 메모리의 데이터를 임시 보관
  2. 주소 레지스터 : 메모리 주소를 저장

📌 사용자 불가 레지스터(user-invisible register)

- 데이터 레지스터, 주소 레지스터 외에 특별한 용도로 사용되는 레지스터(특수 레지스터)
- 사용자가 임의로 값을 변경할 수 없음
- 종류
  1. 프로그램 카운터(PC) : 다음에 실행할 명령어 주소 저장
  2. 명령어 레지스터(IR) : 현재 실행 중인 명령어 저장
  3. 메모리 주소 레지스터(MAR) : 메모리에서 데이터를 처리할 때 해당 주소를 저장
  4. 메모리 버퍼 레지스터(MBR) : 메모리에서 데이터를 처리할 때 해당 값을 저장

### 버스의 종류

📌 시스템 버스

- CPU, 메모리, 주변 장치 간 데이터를 주고 받을 때 사용
  → 데이터 예시 : 제어 신호, 메모리 주소 등

📌 시스템 버스의 종류

1. 제어 버스 : 제어 신호, CPU 제어 장치와 연결, 양방향
2. 주소 버스 : 메모리 주소, MAR과 연결, 단방향(CPU ⇒ [주소 버스] ⇒ 메모리, 주변 장치)
3. 데이터 버스 : 데이터, MBR과 연결, 양방향

### CPU 비트의 의미

📌 버스의 대역폭(bandwidth)

- 한 번에 전달할 수 있는 데이터의 최대 크기
- 이는 CPU가 한 번에 처리할 수 있는 데이터의 크기와 같음

```
[버스의 대역폭] == [워드] == [레지스터 크기] == [메모리에 한 번에 저장할 수 있는 데이터 크기]
```

📌 워드(word)

- CPU가 한 번에 처리할 수 있는 데이터의 최대 크기

## 2.2 메모리의 종류와 부팅

📌 메모리의 종류

- RAM(Random Access Memory) : 읽기, 쓰기 가능
  - 휘발성 메모리 : DRAM, SRAM, SDRAM
  - 비휘발성 메모리 : 플래시 메모리, SSD
- ROM(Read Only Memory) : 읽기만 가능

📌 메모리 보호

- 필요성 : 여러 프로그램이 메모리에서 실행되므로
- OS도 SW라서 메모리 보호에 HW가 필요함
- 경계 레지스터의 값을 벗어나면 인터럽트 발생 → OS에게 제어권 넘어감

📌 부팅(booting)

- 컴퓨터를 켰을 때 OS를 메모리에 올리는 과정
- 과정
  1. 전원 ON
  2. BIOS 실행
     1. HW 초기화
     2. 디스크의 부트스트랩 실행(OS를 로드하는 프로그램)

# 3. 컴퓨터 성능 향상 기술

## 3.1 버퍼

📌 버퍼(buffer)

- 일정량의 데이터를 모아서 옮겨 속도 차이를 완화하는 장치

📌 스풀(SPOOL: Simultaneous Peripheral Operation On-Line)

- CPU와 IO 장치가 독립적으로 동작하도록 고안된 SW 버퍼
- ex. 프린터의 스풀러(spooler)
  → 스풀러 : 인쇄할 내용을 순차적으로 출력하는 SW, 출력 명령을 내릴 프로그램과 독립적으로 동작함
  → 인쇄할 내용을 하드디스크에 저장해두고, 프로그램은 다른 작업을 할 수 있음

📌 캐시(cache)

- 메모리와 CPU 간 속도 차이를 완화하기 위해 메모리의 데이터를 미리 가져와 저장해두는 임시 장소

## 3.2 저장장치의 계층 구조

📌 저장장치의 계층 구조(storage hierarchy)

- 속도가 빠르고 값이 비싼 저장장치를 CPU 쪽에 배치해서 적절한 가격으로 빠른 속도와 큰 용량을 얻는 방법
- 문제 : 중복되는 데이터의 일관성 유지

## 3.3 인터럽트

📌 오늘날 컴퓨터 시스템 : 인터럽트 방식(interrupt)

- 현대는 주변장치가 많아서 폴링 방식을 사용하면 작업 효율이 너무 떨어짐
- 인터럽트 : 입출력 관리자가 CPU에 보내는 완료 신호
- 인터럽트 방식은 데이터 입출력이 진행되는 동안 CPU는 다른 작업을 할 수 있음
  → ∴ 시스템 효율 ↑

📌 인터럽트 방식의 동작 과정

1. CPU : 입출력 관리자에게 입출력 명령을 보냄
2. 입출력 관리자 : 명령어에 따라 데이터를 메모리나 IO장치로 옮김
3. 입출력 관리자 : 데이터 전송이 완료되면 CPU에게 완료 신호(인터럽트)를 보냄
4. CPU : 인터럽트를 받으면 진행 중인 작업을 중단하고, 옮겨진 데이터를 처리

## 3.4 직접 메모리 접근

📌 직접 메모리 접근(DMA, Direct Memory Access)

- 입출력 관리자가 메모리에 접근할 수 있는 권한

📌 DMA의 필요성

- 입출력 관리자는 CPU가 요청한 데이터를 메모리에 넣어야함
- 메모리는 CPU만 접근 권한을 갖고 있음
- 따라서 입출력 관리자는 메모리에 접근할 수 있는 권한이 필요(DMA)

## 3.5 메모리 맵 입출력

📌 메모리 맵 입출력(MMIO, Memory Mapped I/O)

- 메모리의 일정 공간을 입출력에 할당하는 기법

📌 MMIO의 필요성

- DMA를 사용하면 메모리가 복잡해짐
  → ∴ CPU가 넣은 데이터와 DMA가 넣은 데이터를 분리

## 3.6 사이클 훔치기

📌 사이클 훔치기(cycle stealing)

- CPU의 메모리 접근과 DMA가 동시에 일어났을 때 DMA가 먼저 실행되는 것
- ∵ IO 장치 속도가 더 느리므로
- CPU 입장에서 DMA가 사이클을 훔쳐간 것이라서 “사이클 훔치기”

# 4. 멀티 프로세싱

## 4.1 멀티코어 시스템

📌 단일 프로세서 시스템(single processor system)

- 컴퓨터 한 대에 CPU가 1개인 시스템
- 시스템 성능 향상 방법 : CPU 클록 높이기, 캐시 크기 늘리기
  → 그러나 이런 방법은 발열 문제, 비용 문제가 있음
  → ∴ CPU 코어를 여러 개 만들거나 동시에 실행 가능한 명령 개수를 늘리는 방법 사용

📌 멀티 프로세서 시스템(multi processor system)

- 컴퓨터 성능을 높이기 위해 CPU를 여러 개 설치한 시스템
- CPU마다 레지스터, 캐시를 갖고 메인메모리를 공유
- 장점 : 많은 작업을 동시에 실행 가능

📌 멀티코어(multi-core) 시스템

- 단일 프로세서 시스템을 유지하면서 멀티프로세싱이 가능한 시스템
- 하나의 CPU 칩에 CPU 코어를 여러 개 만들어서 동시 작업 처리

## 4.2 CPU 멀티스레드

📌 명령어 병렬 처리(instruction parallel processing)

- 하나의 코어에서 여러 개 스레드로 명령어를 처리하는 방법

📌 현대의 CPU

- 현대의 CPU는 멀티코어와 명령어 병렬 처리를 둘 다 사용

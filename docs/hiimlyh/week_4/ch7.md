# CH7 물리 메모리 관리

## 📌 메모리 관리의 개요

### 메모리 이해하지

> 메모리의 구조는 1B(바이트) 크기로 나뉘어 0번지부터 시작합니다. CPU는 메모리에 있는 내용을 가져오거나 작업 결과를 메모리에 저장하기 위해 **메모리 주소 레지스터(MAR, Memory Address Register)**를 사용합니다. 이 레지스터는 CPU가 접근하고자 하는 메모리 주소를 저장하는 역할
>
- 운영체제도 프로그램 → 메모리에 올라와야 사용 가능
- 부팅시 하드디스크에 저장된 운영체제가 메모리에 올라감

### 메모리 관리의 이중성

> 메모리 관리란 할당된 공간이 부족하면 새로 확보하고, 작업 중인 프로세스를 옮기고, 빈 공간이 여러 개 생기면 합치는 등의 매우 복잡한 작업
>
- 프로세스는 메모리를 독차지 하려 함 → why? → 작업이 편리함
- 메모리 관리자 → 효율적으로 하려함 → 관리의 편리함

### 계층적 메모리 구조

프로그램을 SSD 같은 저장장치가 아니라 메모리에서 실행하는 이유는 속도와 비용의 균형 때문입니다. 느리고 값싼 하드디스크는 제2저장장치로 사용하고, 비싸고 빠른 메모리는 작업 공간으로 사용합니다. 같은 맥락에서 메모리보다 용량은 작지만 속도가 빠른 캐시 메모리를 추가로 사용합니다. 이렇게 메모리를 계층적 구조로 만들어 작업 속도를 올리고 가격을 낮추는 방법을 **계층적 메모리 구조**라고 합니다.

## 컴파일러와 인터프리터의 동작

> 언어 번역 프로그램은 사람이 이해하기 **쉬운 고급 언어(high level language)**로 작성된 소스코드를 컴퓨터가 직접 실행할 수 있는 기계어로 변환해주는 도구
>
- **컴파일러**: 전체 소스코드를 한 번에 기계어로 변환한 후 실행, 마치 책 전체를 한 번에 번역한 후 읽는 것과 같음
    - 예: C언어로 작성된 `hello.c` 파일을 컴파일하면 `hello.exe`라는 실행 파일이 생성됩니다.
    - 대표적인 컴파일 언어: C, C++, Java(바이트코드로 컴파일), Rust
- **인터프리터**: 소스코드를 한 줄씩 해석하며 즉시 실행 마치 통역사가 한 문장씩 실시간으로 번역해주는 것과 유사
    - 예: Python 코드 `print("Hello World")`를 입력하면 즉시 해석되어 결과가 출력
    - 대표적인 인터프리터 언어: Python, JavaScript(JIT), Ruby, PHP

## 컴파일러의 목적

- **오류 발견 및 검증**: 컴파일러는 코드 실행 전에 다양한 오류를 찾아냅니다.
    - 예: `int total = "Hello";`와 같이 문자열을 정수형 변수에 할당하려 할 때 "Type mismatch" 오류를 표시
- **코드 최적화**: 실행 속도와 메모리 사용을 개선합니다.
    - 예: `int x = 5; int y = 3; int z = x + y;`를 `int z = 8;`로 최적화 가능

## 컴파일러와 인터프리터의 차이

1. **실행 준비 시간**:
    - 컴파일러: 초기 변환 시간이 길지만 한 번 컴파일하면 이후 실행 빠름
    - 인터프리터: 즉시 실행이 가능하여 빠른 개발과 테스트가 용이
2. **실행 속도**:
    - 컴파일러: 최적화된 기계어를 생성하므로 일반적으로 더 빠름
    - 인터프리터: 실행 중에 번역하므로 상대적으로 느립니다.
3. **오류 처리**:
    - 컴파일러: 실행 전에 모든 문법 오류를 검출합니다. 예: C++ 프로그램에서 세미콜론(;)을 빼먹으면 컴파일 단계에서 오류가 발생합니다.
    - 인터프리터: 실행 중에 해당 줄에 도달했을 때 오류를 발견합니다.
        - 예: Python에서 오타가 있는 코드는 해당 라인이 실행될 때까지 오류가 발견되지 않음
4. **플랫폼 독립성**:
    - 컴파일러: 대개 특정 플랫폼용 기계어를 생성(Java는 JVM 바이트코드라 예외).
    - 인터프리터: 보통 플랫폼 독립적으로 작동

## 컴파일 과정

1. **전처리(Preprocessing)**: 소스코드 내 주석 제거, 매크로 확장, 헤더 파일 포함 등을 수행
    - 예: C언어의 `#include <stdio.h>`는 이 단계에서 실제 stdio.h 파일의 내용으로 대체
2. **컴파일**: 소스코드를 목적 코드**(object code)**로 변환
    - 예: C 소스 파일(.c)은 목적 파일(.o 또는 .obj)로 변환

# 메모리 관리자의 역할

- **메모리 관리 유닛(MMU)**은 CPU와 메모리 사이에 위치한 하드웨어로, 핵심 기능을 수행
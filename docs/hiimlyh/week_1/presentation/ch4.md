# CH4 CPU 스케줄링

## ✅ CPU 스케줄링

CPU 스케줄러는 관리의 범주를 나누어 스케줄링한다, CPU 스케줄링은 규모에 따라 고수준 스케줄링, 중간 수준 스케줄링, 저수준 스케줄링으로 구분된다.

1. **고수준 스케줄링**
- **목적:** 시스템 내의 **“전체 작업 수”**를 조절하는 것
- 메인프레임과 같은 대규모 시스템의 일괄 작업 처리
- **가장 큰 틀**에서 이루어지는 CPU 스케줄링
    - 작업의 승인/거부를 결정(승인 스케줄링)
    - 시스템 부하를 고려하여 새 작업의 시작 여부를 결정
    - 멀티 프로그래밍정도(동시 실행 가능한 프로세스 총 개수)결정

1. **저수준 스케줄링 (단기 스케줄링)**
- **목적:** CPU 할당 및 프로세스 상태 전환 결정
- 가장 작은 단위의 스케줄링
    - 아주 짧은 시간 단위로 발생
    - 준비↔실행↔대기 상태 간 프로세스 전환 관리
    - 실제 작업이 이루어지는 단계
- 오늘날의 CPU 스케줄러

1. **중간 수준 스케줄링**
- **목적**: 시스템 과부하 방지를 위한 활성 프로세스 수 조절
- 중지와 활성화로 전체 시스템의 활성된 프로세스 수를 조절하여 시스템의 과부화를 방지
    - 활성화된 프로세스 중 일부를 보류 상태로 전환
    - 시스템 부하 완화 시 보류된 프로세스 재활성화
    - 활성(active)↔중지(suspend) 상태 전환으로 조절
- 저수준 스케줄링의 원활한 작동을 지원하는 완충(buffer) 역할

> **고수준**: 어떤 작업을 시스템에 받아들일지 결정 (입장 관리자)
>
>
> **중간 수준**: 시스템 과부하 시 일부 프로세스를 잠시 중단 (인구 조절사)
>
> **저수준**: CPU를 어떤 프로세스에 할당할지 실시간 결정 (실행 관리자)
>

### ✅ 스케줄링의 목적

6가지: 공평성, 효율성, 안정성, 확장성, 반응시간의 보장, 무한 연기 방지

- 공평성: 모든 프로세스가 공평하게 자원을 받아야 한다.
- 효율성: 시스템 자원이 쉬는 시간 없이 사용되도록 스케줄링하고, 쉬고있는 자원을 사용하려는 프로세스에는 우선권을 줘야 한다.
- 안전성: 우선순위를 사용하여 중요 프로세스 먼저 작동하도록 하고, 시스템 자원을 점유하거나 파괴하려는 프로세스로 부터 자원을 보호해야 한다.
- 확장성: 프로세스가 증가해도 시스템이 안정적으로 작동해야한다.
- 반응 시간 보장: 응답이 없으면 멈춘것으로 가정하기에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다.
- 무한 연기 방지: 특정 프로세스의 작업이 무한히 연기되어서는 안된다.

### ✅ 스케줄링 시 고려 사항

선점(빼앗을 수 있음), 비선점(빼앗을 수 없음)

- **선점형 스케줄링: 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식**
    - 시분할 방식 스케줄링에 사용
- **비선점형 스케줄링:** 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 뺴앗을 수 없는 스케줄링
    - 일괄 작업 방식 스케줄링에 사용

### 프로세스 우선순위

우선순위가 높은 프로세스에 CPU를 먼저 할당한다.

- 중요도에 따라 프로세스의 우선순위를 다르게 함.
- 우선순위가 높은 프로세스가 CPU를 먼저 차지 및 더 오래 차지
- 커널 프로세스의 우선순위가 일반 프로세스보다 높음
- 프로세스 우선순위가 같다는 것은 모든 프로세스의 중요도가 같다는 것을 의미한다.

**CPU 집중 프로세스:** 수학 연산과 같이 CPU를 많이 사용하는 프로세스로 CPU 버스트가 많다

**입출력 집중 프로세스:** 입출력을 많이 사용하는 프로세스

> CPU 집중 프로세스와 입출력 집중 프로세스가 같이 있다면 입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적 입출력 집중 프로세스가 실행 상태로 가면 입출력 요구에 의해 대기 상태로 옮겨지기 때문에 다른 프로세스가 CPU를 사용 할 수 있다.
>

### 전면 프로세스와 후면 프로세스

- **전면 프로세스**
    - GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스
    - 현재 입력과 출력을 사용하는 프로세스며 사용자와 상호 작용이 가능하여 상호작용 프로세스라고 함

- **후면 프로세스**
    - 사용자와 상호작용이 없는 프로세스기에 후면 프로세스는 전면 프로세스보다 CPU를 할당 받을 확률이 낮음.

- 우선순위가 높음[커널, 전면, 대화형, 입출력 집중]프로세스
- 우선순위가 낮음[일반, 후면, 일괄 처리, CPU 집중]프로세스

### 다중 큐

**준비 상태의 다중큐**

- **다중 큐**
    - 우선 순위에 따라 여러 개의 큐로 프로세스를 관리하는 시스템
    - CPU가 프로세스를 효율적으로 관리하기 위함
    - 작동 방식은 프로세스는 준비 상태에 진입할 때마다 자신의 우선순위에 해당하는 큐의 마지막에 추가됨

- 우선순위 배정 방식
    - **고정 우선순위 방식:**
        - 프로세스가 시작부터 종료까지 동일한 우선순위 유지 (변경되지 않는 방식)
        - **장점:** 구현이 간단함
        - **단점:** 시스템 환경 변화에 대응하기 어려워 작업 효율성이 떨어짐
    - **변동 우선순위 방식**
        - 프로세스 실행 중에 우선순위가 동적으로 변경됨
        - **장점**: 시스템 상황에 따라 유연하게 대응하여 효율성 향상
        - **단점**: 구현이 복잡하고 우선순위 변경 알고리즘 설계가 어려움

**대기 상태의 다중 큐**

- 시스템의 효율성 향상을 위한 입출력 관리 (입출력을 기다리는 프로세스끼리 모여 있는 대기큐)
- 같은 유형의 입출력을 요청한 프로세스들을 하나의 큐로 그룹화
- 유사한 작업을 묶어서 처리함으로써 입출력 작업의 효율성 증가

> 준비 큐는 한 번에 하나의 프로세스를 꺼내어 CPU를 할당하는 반면, 대기 큐는 여러 개의 프로세스 제어 블록을 동시에 꺼내어 준비 상태로 옮긴다
>

### 스케줄링 알고리줌

**▶️ 크게 비선점형 알고리즘과 선점형 알고리즘으로 나뉜다.**

**스케줄링 알고리즘의 선택 기준**

- **CPU 사용률**: 전체 시스템 동작 시간 중 CPU가 얼마나 바쁘게 일하는지를 나타내는 지표로, 높을수록 효율적
- **처리량**: 단위 시간당 완료되는 프로세스의 수, 이 수치가 클수록 좋은 알고리즘
- **대기 시간**: 프로세스가 준비 큐에서 기다리는 총 시간, 짧을 수록 좋다.
- **응답 시간**: 요청 후 첫 반응이 오기까지 걸리는 시간, 짧을 수록 좋다.
- **반환 시간**: 프로세스가 시작부터 종료까지 걸리는 총 시간 (대기 시간 + 실행 시간)

**1. FCFS (First-Come, First-Served)**

- **동작 방식:** 준비 큐에 도착한 순서대로 CPU 할당 (선입 선출 스케줄링)
- **장점**: 구현이 단순하고 공평함
- **단점**: 처리 시간이 긴 프로세스가 앞에 있으면 뒤의 프로세스들이 오래 기다리는 '콘보이 효과(Convoy Effect)' 발생
- **e.g)** P1(24ms), P2(3ms), P3(3ms) 순서로 도착 시, P2와 P3는 P1이 끝날 때까지 기다려야 함

**2. SJF (Shortest Job First)**

FCFS 스케줄링의 콘보이 효과를 완화하여 시스템의 효율성을 높이는 것.

- **동작 방식**: 실행 시간이 가장 짧은 프로세스에 먼저 CPU 할당
- **장점**: 평균 대기 시간 최소화
- **단점**:
    - 실행 시간이 긴 프로세스는 CPU를 할당받지 못하는 '아사 현상(Starvation)' 발생 가능
    - 프로세스의 실행 시간을 미리 알기 어려움
- **e.g)** P1(7ms), P2(4ms), P3(1ms), P4(4ms) 순서로 준비 큐에 있으면, 실행 순서는 P3→P2→P4→P1

**3. HRN (Highest Response-ratio Next)**

- **동작 방식**: 우선순위 = (대기 시간 + CPU 사용 시간) / CPU 사용 시간
- **장점**: SJF의 아사 현상 완화, 대기 시간을 고려하여 더 공정한 스케줄링
- **단점**: 우선순위 계산 오버헤드, 완벽한 공평성은 보장하지 못함 (많이 사용되지는 않는다)
- **e.g)** 대기 시간이 길어질수록 우선순위가 높아져 CPU 사용 시간이 긴 프로세스도 결국 실행 기회를 얻음

### 선점형(Preemptive) 알고리즘

CPU를 사용 중인 프로세스라도 우선순위가 높은 프로세스가 등장하면 CPU를 빼앗길 수 있는 방식입니다.

**1. 라운드 로빈 (Round Robin)**

- **동작 방식**: FCFS에 시간 할당량(타임 슬라이스) 추가, 할당 시간 종료 시 다음 프로세스에게 CPU 양도
- **장점**: 공평한 CPU 분배, 응답 시간 향상
- **단점**: 문맥 교환(Context Switch) 시간이 추가되어 오버헤드 증가
- e.g) 타임 슬라이스 4ms 라 가정시, P1(20ms), P2(3ms), P3(5ms) 순서로 준비 큐에 있으면, 실행 순서는 P1(4ms)→P2(3ms 완료)→P3(4ms)→P1(4ms)→P3(1ms 완료)→P1(4ms)...

**2. SRT (Shortest Remaining Time)**

- **동작 방식**: CPU를 할당 받을때 남은 실행 시간이 가장 짧은 프로세스를 선택하는 SJF의 선점형 버전
- **장점**: 평균 대기 시간 최소화, 짧은 작업의 빠른 완료
- **단점**:
    - 아사 현상 발생 가능
    - 남은 실행 시간을 지속적으로 추적/계산해야 하는 오버헤드
    - 잦은 문맥 교환으로 인한 성능 저하
- 실행 중 더 짧은 프로세스가 도착하면 즉시 CPU 선점

**3. 다단계 큐 (Multi-Level Queue)**

- 프로세스 특성에 따라 여러 개의 큐로 분류, 각 큐마다 다른 스케줄링 알고리즘 적용
- **장점**:
    - 다양한 프로세스 특성에 맞는 스케줄링 가능
    - 우선순위별로 타임 슬라이스 조절 가능 (높은 우선순위: 작은 타임 슬라이스, 낮은 우선순위: 큰 타임 슬라이스)
- **단점**: 우선순위가 낮은 큐의 프로세스는 실행 기회가 적음
- e.g) 포그라운드(대화형) 프로세스는 RR, 백그라운드(배치) 프로세스는 FCFS로 스케줄링

**4. 다단계 피드백 큐 (Multilevel Feedback Queue)**

- **동작 방식**: 다단계 큐의 확장 버전으로, 프로세스가 큐 사이를 이동할 수 있음
- **동작 과정**:
    1. 모든 프로세스는 처음에 가장 높은 우선순위 큐에 진입
    2. CPU를 사용한 후, 우선순위가 하나 낮은 큐로 이동
    3. 낮은 우선순위 큐일수록 더 큰 타임 슬라이스 할당
    4. 오랫동안 대기한 프로세스는 상위 큐로 승격 가능 (아사 현상 방지)
- **장점**:
    - 다양한 프로세스 유형에 적합한 유연한 스케줄링
    - 공평성과 효율성의 균형 유지
    - I/O 중심 프로세스와 CPU 중심 프로세스의 균형 있는 처리
- 현대 운영체제에서 가장 널리 사용되는 스케줄링 알고리즘

### **선점/비선점 모두 가능한 알고리즘**

**우선순위 스케줄링 (Priority Scheduling)**

- **작동 방식**: 각 프로세스에 우선순위 값 부여, 높은 우선순위 프로세스에 CPU 먼저 할당
- **선점형**: 더 높은 우선순위 프로세스가 준비 큐에 들어오면 현재 실행 중인 프로세스를 중단
- **비선점형**: 현재 실행 중인 프로세스가 완료되거나 I/O 대기 상태가 될 때까지 실행
- **장점**: 중요 작업의 빠른 처리 가능
- **단점**: 우선순위가 낮은 프로세스의 아사 현상 발생 가능

### 인터럽트 처리

입출력을 요청하고 입출력이 완료되면 이벤트를 발생시켜 이 사실을 알리는 것

**동기적 인터럽트와 비동기적 인터럽트**

- 동기적 인터럽트: 프로세스가 실행 중인 명령어로 인해 발생
    - 프로그램 상의문제 때문에 발생하는 인터럽트
    - 컴퓨터 작업자가 의도적으로 프로세스를 중단하기 위해 발생시킨 인터럽트 
    - 입출력장치 같은 주변장치의 조작에 의한 인터럽트
    - 산술 연산 중 발생하는 인터럽트

- 비동기적 인터럽트 : 실행 중인 명령어와 무관하게 발생
  - 하드디스크 읽기 오류, 메모리 불량 등의 하드웨어적 오류로 발생
  - 
**인터럽트 처리 과정**
1. 인터럽트가 발생하면 현재 실행중인 프로세스는 일시정지, 재시작하기 위해 상태 정보를 PCB에 임시 저장함
2. 인터럽트 컨트롤러가 실행되어 인터럽트 처리 순서 결정
3. 먼저 처리할 인터럽트가 결정되면 인터럽트 벡터에 등록된 인터럽트 핸들러 (해당 이벤트를 처리할 함수의 시작 주소) 실행
4. 핸들러가 인터럽트 처리를 마치면 일시정지된 프로세스가 다시 실행되거나 종료

### 인터럽트와 이중모드 
- 이중모드 
  - 운영체제가 커널 모드와 사용자 모드를 전환하며 일 처리를 하는것 
  - 궁극적인 목적은 자원 보호 
# CH9 가상 메모리 관리

### 요구 페이징 (Demand Paging)

프로세스가 필요로 하는 데이터를 언제 메모리로 가져올지 결정하는 것이 가져오기 정책,
요구 페이징: 프로세스가 요청할 때 메모리로 가져오는 것

**반대 개념:** 미리 가져오기 (캐시)

- 메모리 효율적으로 관리: 필요한 모듈만 메모리에 유지
- 응답 속도 향상: 전체를 로딩하지 않아 초기 실행 속도가 빠름
- e.g) 포토샵 -본 프로그램만 로딩하고 노이즈제거, 필터 등등 기타 필요할 때만 로딩

> 순수한 스와핑: 프로세스의 모든 페이지를 메모리에 올림
게으른 스와핑: 사용자가 요구할 때만 메모리에 올림
>

### 페이 테이블 엔트리의 구조

페이지 테이블의 한 행(엔트리) 구성:

- 페이지 번호
- 플래그 비트
    - 접근 비트(a): 페이지 사용 여부(참조 비트)
    - 변경 비트(m): 데이터가 새로운 값으로 오염 되었다라는 의미에서 더티 비트
    - 유효 비트(v): 페이지가 메모리에 있는지 여부(현재 비트)
    - 접근 권한 비트: 읽기(r), 쓰기(w), 실행(x) 권한
- 프레임 번호(주소 필드)

### 페이지 부재

> 프로세스가 페이지를 요청했을 때 그 페이지가 메모리에 없는 상황을 **페이지 부재**(Page fault) 라고 함
>

**처리 과정**

1. 유효 비트 확인 (1일시 페이지 부재)
2. 스왑 영역에서 요청한 페이지(E) 찾음
3. 메모리에 빈 공간이 없으면 희생 페이지 선정
4. 희생 페이지를 스왑 영역으로 내보냄(스왑 아웃)
5. 페이지 테이블 갱신

### 세그먼테이션 오류 vs 페이지 부재

- **세그먼테이션 오류**: 접근 권한 없는 메모리 접근 시 발생, 프로세스 강제 종료
- **페이지 부재**: 페이지가 메모리에 없을 때 발생, 페이지를 물리 메모리로 가져와 해결

### 페이지 교체 알고리즘

> 메모리가 꽉 차있을때 어떤 페이지를 스왑 영역으로 보낼지 결정 **(재배치 정책)**
>

**개요**

페이지 교체 알고리즘은 스왑 영역으로 보낼 페이지를 결정하는 알고리즘으로, 메모리에서 앞으로 사용할 가능성이 적은 페이지를 대상 페이지로 선정하여 주재를 줄이고 성능을 향상 시킴

**페이지 교체 알고리즘의 종류**

| 종류 | 알고리즘 | 특징 |
| --- | --- | --- |
| 간단한 알고리즘 | 무작위 | 무작위로 대상 페이지를 선정하여 스왑 영역으로 보냄 |
|              “” | FIFO | 처음 메모리에 올라온 페이지를 스왑영역으로 보냄 |
| 이론적 알고리즘 | 최적 | 미래의 메모리 접근 패턴을 보고 대상 페이지를 선정하여 스왑 영역으로 보냄 |
| 최적 근접 알고리즘 | LRU | 시간적으로 멀리 떨어진 페이지를 스왑 영역으로 보냄 |
|         “” | LFU | 사용 빈도가 적은 페이지를 스왑 영역으로 보냄 |
|            “”  | NUR | 최근에 사용한 적이 없는 페이지를 스왑 영역으로 보냄 |
|  | FIFO 변형 | FIFO 알고리즘을 변형하여 성능을 높임 |

### 무작위 페이지 교체 알고리즘

가장 간단한 구현 방식

- 스왑 영역으로 쫓아낼 대상 페이지를 특별한 로직 없이 무작위 선정
- 지역성을 고려하지 않기에 자주 사용되는 페이지가 선정 되기도함
- 성능이 좋지 않아 거의 사용 안됌

### FIFO 페이지 교체 알고리즘

선입 선출 페이지 교체 알고리즘

- 시간상 메모리 가장 먼저 들어온 페이지를 대상으로 선정 후 스왑영역으로 쫓아냄
- FIFO 는 큐(Queue) 로 구현됨
- 메모리 맨위껀 가장 오래됨,  새 페이지는 맨 아래 추가
- 메로리가 꼬가차면 맨위 페이지가 스왑 영역으로 이동, 그 나머지는 맨위로 이동

**문제점:** 오래되었더라도 자주 사용되는 페이지를 고려하지 않음

### 최적 페이지 교체 알고리즘

- 앞으로 가장 오랫동안 사용하지 않을 페이지를 스왑 영역으로 옮김
- 미래의 메모리 접근 패턴을 보고 대상 페이지 선정하기에 성능은 좋지만 구현이 불가능

## 최적 근접 알고리즘 (과거 데이터 기반 예측)

과거의 데이터를 바탕으로 미래 접근 패턴을 추정하는 알고리즘

### LRU 페이지 교체 알고리즘 (Least Recently Used)

> 최근 최소 사용 페이지 교체 알고리즘
>
- 가장 오랫동안 사용되지 않은 페이지를 스왑영역으로 옮김
- 구현 방식:
    - 메모리 접근 시간을 기반한 구현: 페이지 접근 시간 기록 (연산이 이루어진 시간 기준)
    - 카운터 기반: 접근 시간 대신 카운터를 사용
    - 참조 비트 시프트 방식: 각 페이지에 참조 비트 할당, 접근 시 1로변경하며 주기적으로 시프트

**단점: 접근 시간이나 참조 비트를 유지하기 위한 메모리가 추가로 필요하기 때문에 낭비되는 메모리 공간이 많다.**

### LFU 페이지 교체 알고리즘 (Least Frequently Used)

> 최소 빈도 사용 알고리즘
페이지가 몇번 사용되었는지 기준으로 대상 페이지 선정
>
- 가장 적게 사용된 페이지를 스왑 영역으로 옮김
- 페이지별로 사용 횟수(빈도)를 기록
- FIFO보단 성능이 좋음

**단점: 페이지 접근 횟수(빈도)를 표시할 시  추가 공간이 필요하므로 그만큼 메모리 낭비됨**

### NUR 페이지 교체 알고리즘 (Not Used Recently)

> 최근 미사용 페이지 교체 알고리즘
LRU, LFU와 성능이 비슷하지만 메모리 낭비를 최소화한 알고리즘
>
- 페이지당 2비트만 추가(참조 비트, 변경 비트)
    - 참조 비트: 페이지 접근(읽기/실행) 시 1로 설정
    - 변경 비트: 페이지 변경(쓰기/추가) 시 1로 설정

**대상 페이지 선정 우선순위:** (0,0) → (0,1) → (1,0) → (1,1) 이런식으로 즉 접근한 적도ㅡ 변경한 적도 없는 페이지를 스왑 영역으로 옮김

- 모든 페이지가 (1,1)이면 모든 비트를 (0,0)으로 초기화
- 쉽게 구현이 가능하며, LRU, LFU, NUR 페이지 교체 알고리즘이랑 성능이 거의 비슷하며 FIFO 보다 성능이 좋다 이러한 장점 때문에 가장 많이 사용

### FIFO 변형 알고리즘

**2차 기회 페이지 교체 알고리즘**

- FIFO와 유사하지만 큐를 사용
- 페이지 접근 성공 시 해당 페이지를 큐의 맨뒤로 옮김으로 써 기회를 한번 더 줌(기회가 총 2번)
- 성능이 LRU/LFU/NUR보다 약간 낮고, FIFO보다 약간 높은 성능

**단점: 큐를 유지하는 비용이 높고, 페이지가 성공하면 큐의 중간 값을 뒤로 이동하는 작업이 필요**

📌2차 기회 페이지 교체 알고리즘은 FIFO 페이지 교체 알고리즘을 변형한 것이기 떄문에 2차 기회 FIFO 페이지 교체 알고리즘 이라고도 함

### 시계 알고리즘(Clock)

- 2차 기회 알고리즘과 유사하지만 원형큐를 사용함(가장 큰 차이점)
- 포인터가 원형으로 움직이며 대상 페이지를 선정 (시계 처럼 한바퀴 돔)
- 참조 비트가 1인 페이지는 건너뛰고 0으로 변경(한번의 기회를 줌)
- 대상 포인터와 각 페이지앋 참조비트 하나만 추가하면 되기에 공간이 적게 들어 효율적

**단점:**알고리즘이 복잡하고 계산량이 많음

## 스레싱과 프레임 할당

### 스레싱

> 하드디스크의 입출력이 너무 많아 잦은 페이지 부재로 작업이 멈춘 것 같은 상태.
멀티 프로그래밍 정도가 높으면 스레싱 발생
>
- 스레싱은 각 프로세스에 프레임을 할당하는 문제와도 연관되어있다, 실행 중인 여러 프로세스에 프레임을 얼마나 나누어주느냐에 따라 시스템의 성능이 달라짐
- 남아있는 프레임을 실행 중인 프로세스에 적절히 나누어주는 정책이 필요, 프로세스에 프레임을 할당하는 방식은 정적 할당, 동적 할당으로 구분

### 정적 할당

> 정적 할당방식은 프로세스 실행 초기에 프레임을 나누어 준 후 그 크기를 고정 하는 것으로, 균등 할당 방식과 비례 할당 방식이 있다.
>

1. **균등 할당 : 프로세스 크기와 상관없이 사용 가능한 프레임을 모든 프로세스에 동일하게 할당**

![image.png](./images/image%202.png)

🥄 그림에서 C는 4개 밖에 프레임이 없기에 페이지 부재가 발생

🥄 그림에서 B는 프레임이 하나가 남아 메모리 낭비

1. **비례 할당 : 프로세스의 크기에 비례하여 프레임을 할당하는 방식**

![image.png](./images/image%203.png)

> 프로세스의 크기를 고려하지 않고 고정 할당보다 좀 더 현실적인 방식
>

**문제점: 프로세스가 실행되면서 필요로 하는 프레임을 유동적으로 반영 불가,**

      사용하지 않을 메모리 공간 낭비

### 동적 할당

> 프로세스를 실행하는 중에서 시시각각 변하는 요청에 따라 프레임을 나누어 주기도 하고 회수도 하는 방식이다. 작업집합 모델을 사용하는 방식과 페이지 부재를 사용하는 방식이 있음
>

1. **작업집합 모델**
- 지역성 이론을 바탕
- 최근 일정 시간 동안 참조된 페이지들을 집합으로 만듬 이 집합에 있는 페이지들을 물리 메모리에 유지하여 프로세스의 실행을 도움

![image.png](./images/image%204.png)

**작업집합의 크기:** 물리 메모리에 유지할 페이지의 크기

**작업집합의 윈도우:** 작업집합에 포함되는 페이지의 범위

📌 작업 집합모델은 프로세스가 효율적으로 실행되기 위해 필요한 페이지의 집합을 관리하며 핵심은 윈도우 크기의 적절한 설정

**윈도우가 너무 클 경우:** 필요없는 페이지가 메모리에 남아 다른 프로세스 자원을 차지

**윈도우가 너무 작을 경우:** 필요한 페이지가 스왑 영역으로 이동하여 프로세스 성능 저하

### 페이지 부재 빈도

> 페이지 부재 빈도 방식은 이러한 한계를 보안하기 위한 동적 페이지 할당 방법
>

![image.png](./images/image%205.png)

**페이지 부재횟수를 기록하여 페이지 부재 비율을 계산하는 방식으로 상한선, 하한선 설정

상한선과 하한선 설정**

- **상한선 초과**: 페이지 부재가 너무 많음 → 프레임 추가 할당
- **하한선 미만**: 페이지 부재가 너무 적음 → 불필요한 프레임 회수

**동적으로 조절**

- 프로세스를 실행하면서 추가적으로 페이지 할당하거나 회수하여 적정페이지 할당량을 조절

### 전역 교체와 지역 교체

- **전역 교체:** 전체 프레임을 대상으로 교체 알고리즘을 적용
- **지역 교체:** 현재 실행중인 프로세스의 프레임을 대상으로 교체 알고리즘을 적용

참고 및 모든 이미지 출처:[https://github.com/shinhyunji36/easy-to-learn-os-study/blob/main/09 가상 메모리 관리/요약/9-3 스레싱과 프레임 할당.md](https://github.com/shinhyunji36/easy-to-learn-os-study/blob/main/09%20%EA%B0%80%EC%83%81%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EA%B4%80%EB%A6%AC/%EC%9A%94%EC%95%BD/9-3%20%EC%8A%A4%EB%A0%88%EC%8B%B1%EA%B3%BC%20%ED%94%84%EB%A0%88%EC%9E%84%20%ED%95%A0%EB%8B%B9.md)
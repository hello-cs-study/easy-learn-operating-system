# 7장 물리 메모리 관계

# 메모리 관리의 개요

폰노이만 구조에서 메모리 = 유일한 작업공간.

모든 프로그램은 메모리에 올라와야 실행할 수 있다.

### 메모리 이해하기

CPU는 메모리에 있는 데이터를 가져오가나 작업 결과를 메모리에 저장하기 위해 주소를 사용.

CPU와 메모리는 속도 차이가 심하다. 이를 극복하기 위해 메모리에 있는 데이터를 CPU 안의 캐시를 만들어두고 메모리의 일정 부분을 미리 가져와 작업함.

### 메모리 관리의 이중성

![image.png](image.png)

**프로세스 입장에서는 메모리를 독차지하려 하고, 메모리 관리자 입장에서는 관리를 효율적으로 하고 싶어하는데 이를 메모리 관리의 이중성**이라고 한다.

### 코드의 번역과 실행

**컴파일러 방식**

- 오류 발견
- 소스코드 최적화

컴파일러는 실행 전에 소스코드를 점검하여 오류를 수정하고 필요 없는 부분을 정리하여 최적화된 실행 파일을 만든다. 그러나 인터프리터는 한 행씩 위에서부터 아래로 실행되기 때문에 같은 일을 반복하는 경우나 필요 없는 변수를 확인할 수 없다.

**컴파일러의 컴파일 과정**

컴파일러는 오류가 있는지 점검하고 최적화를 통해 필요 없는 변수와 코드를 삭제한다. 이렇게 해서 만들어진 기계어 코드가 **목적 코드**다. 목적 코드는 기계어 코드로 가기 직전의 초벌 번역 상태.

![image.png](image%201.png)

목적 코드가 만들어지면 라이브러리에 있는 코드를 목적 코드에 삽입하여 최종 실행 파일을 만든다.

라이브러리 = 자주 사용하는 함수를 시스탬 내에 미리 만들어둔 것

오늘날의 프로그래밍에서는 메서드의 자리를 비워 놓고 컴파일 한 후 메서드 문의 실행 코드를 라이브러리에서 가져와 실행하는 방법을 사용. 이렇게 실행할 때 삽입되는 함수를 가진 라이브러리를 동적 라이브러리라고 한다.

### 메모리 관리 작업

메모리 관리 작업 = 가져오기(fetch), 배치(placement), 재배치(replacement)

![image.png](image%202.png)

# 메모리 주소

메모리에 접근할 때는 주소를 이용한다. 메모리 주소는 물리 주소와 논리 주소로 나뉜다.

### 32bit CPU와 64bit CPU의 차이

- 32bit CPU = 한 번에 다룰 수 있는 데이터의 최대 크기가 32bit
    - 메모리 주소를 지정하는 레지스터인 메모리 주소 레지스터의 크기가 32bit 이므로 표현할 수 있는 메모리 주소의 범위는 2^32 → 즉, **메모리를 최대 4GB까지 사용할 수 있다.**
- 64bit CPU = 한 번에 다룰 수 있는 데이터의 최대 크기가 64bit
    - 메모리를 2^64까지 → 즉, 메모리를 거의 무한대에 가깝게 사용할 수 있다.

### 논리 주소와 물리 주소

**메모리 영역의 구분**

- 단순 메모리 구조: 한 번에 한가지 일만 처리하는 일괄 처리 시스템

![image.png](image%203.png)

이러한 구조는 사용자 프로세스가 운영체제의 크기에 따라 매번 적재되는 주소가 달라지면 번거로워짐. 이를 해선한 방법이 사용자 프로세스를 메모리의 최상위부터 사용하는 것

![image.png](image%204.png)

사용자가 영역이 운영체제 영역으로 침범하는 것을 막으려면 하드웨어의 도움이 필요한데, 이는 CPU 내에 있는 경계 레지스터가 담당. **메모리 관리자는 사용자가 작업을 요청할 때마다 경계 레지스터의 값을 벗어나는지 검사하고, 만약 경계 레지스터를 벗어나는 작업을 요청하는 프로세스가 있으면 그 프로세스를 종료.**

**논리 주소와 물리 주소의 변환**

![image.png](image%205.png)

- 물리 주소: **메모리 입장에서 바라본 주소**. 즉 운영체제 영역 + 주소의 번지
    - 360 + 40 = 400
- 논리 주소: 시작점을 0으로 놓았을때 40번지의 위치에 있는 주소. **사용자 프로세스 입장에서 바라본 주소**
    - 40 = 40

논리 주소로 이루어진 프로세스를 실행함녀 이를 물리 주소로 변환하는 작업이 필요한데 이를 **메모리 관리 유닛(MMU: Memory Management Unit)이 담당**

![image.png](image%206.png)

1. 사용자 프로세스가 논리 주소 40번지에 있는 데이터를 요청
2. CPU는 메모리 관리 유닛에 40번지에 있는 데이터를 가져오라 명령
3. 메모리 관리 유닛은 재배치 레지스터를 사용하여 메모리 400번지에 저장된 데이터를 가져옴.

# 단일 프로그래밍 환경의 메모리 할당

### 메모리 오버레이

1MB 메모리의 컴퓨터에서 10mb의 프로그램을 실행하려면?

→ 적당한 크기로 잘라서 가져온다. 이를 **메모리 오버레이**라고 한다.

메모리 오버레이에서는 어떤 모듈을 가져오거나 내보낼지는 CPU 레즈서 중 하나인 프로그램 카운터가 결정.

- 한정된 메모리에서 메모리가 큰 프로그램을 실행할 수있다.
- 프로그램 전체가 아니라 일부만 메모리에 올라와도 실행할 수 있다. 즉 메모리를 여러 조각으로 나누어 여러 프로세스에 할당할 수 있다는 의미

### 스왑

메모리가 모자라서 쫓겨난 프로세스를 저장장치의 특별한 공간에 모아두는데 이러한 영역을 스왑 영역이라고 한다.

스왑 영역에서 메모리로 데이터를 가져오는 작업을 스왑인, 데이터를 내보내는 작업을 스왑아웃이라 한다.

![image.png](image%207.png)

예: 실제 메모리의 크기가 1GB, 스왑의 크기가 3GB면 사용자가 인식하는 메모리의 크기는 4GB

→ 스왑을 사용하여 실제 메모리의 모자란 부분을 보충할 수 있음. 사용자 입장에서는 실제 메모리의 크기에 상관없이 큰 프로그램을 실행할 수 있다.

# 다중 프로그래밍 환경의 메모리 할당

### 메모리 분할 방식

- 가변 분할 방식: 프로세스의 크기에 따라 메모리를 나눈다. 메모리의 연속된 공간에 배치되기 떄문에 **연속 메모리 할당**이라고 한다.
    - 장점: 프로세스를 한 덩어리로 하나의 프로세스를 연속된 공간에 배치할 수 있다.
    - 단점: 메모리 관리가 복잡하다.
- 고정 분할 방식: 프로세스의 크기와 상관없이 메모리를 같은 크기로 나눈다. 하나의 프로세스가 여러 개로 나뉘어 배치되기 때문에 **비연속 메모리 할당**이라고 한다.
    - 장점: 메모리 관리가 편리하다
    - 단점: 하나의 프로세스가 여러 곳으로 나뉠 수 있다. → 하지만 실행에 문제가 없기 떄문에 요즘에는 기본적으로 고정 분할 방식을 사용.

![image.png](image%208.png)

### 가변 분할 방식의 메모리 관리

프로세스의 크기에 맞춰 메모리를 할당하는 세그멘테이션 메모리 관리 기법을 사용한다.

![image.png](image%209.png)

- 최초 배치: 단편화를 고려하지 않고 적재가 가능한 첫 번째 공간에 프로세스를 배치하는 방법
- 최적 배치: 크기가 가장 비슷한 곳에 프로세스를 배치하는 방법
- 최악 배치: 가장 큰 공간에 프로세스를 배치하는 것

**조각 모음**

![image.png](image%2010.png)

단편화가 발생할때 이미 배치된 프로세스를 옆으로 ㅇ롬겨 빈 공간들을 하나의 큰 덩어리로 만들어야 하는데 이 작업이 바로 조각 모음.

1. 조각 모음을 하기 위해 이동할 프로세스의 동작을 멈춘다.
2. 프로세스를 적당한 위치로 이동한다.
3. 1,2 작업을 다 마친 후 프로세스를 다시 시작한다.

### 고정 분할 방식의 메모리 관리

페이징 기법을 사용하여 메모리를 관리한다.

### 버디 시스템

가변 분할 방법과 고정 분할 방식의 특징을 모두 가진 시스템으로 고정 분한 방식이 단순하기 때문에**고정 분할 방식을 많이 사용한다.**

# 분할 컴파일과 메모리 관리

### 분할 컴파일

C언어나 자바 언어로 작성한 소스코드는 컴파일 과정을 거쳐 목적 코드가 된다. 컴파일러는 고급 언어로 작성된 소스코드를 기계어로 번역하면서 여러 가지 작업을 수행.

### 변수와 메모리 할당

```java
char str = 'a';
int vol = 7;
float pri = 2.3;
```

![image.png](image%2011.png)

문자형은 1B, 정수형은 4B, 실수형은 8B를 사용

![image.png](image%2012.png)

각 변수는 이름, 종류, 범위, 주소를 가진다.

여기서 중요한 것은 변수가 메모리 주소의 또 다른 이름이라는 것. 기계어 입장에서는 메모리 주소만 필요한데 변수를 사용한 이유는 **프로그래머가 주소 값만으로는 그것이 어떤 주소인지 기억하기 어렵기 때문.** 이렇게 프로그래머가 변수를 사용하여 프로그램을 만들면 컴파이러는 모든 변수를 메모리 주소로 바꾸어 기계어로 된 실행 파일을 만든다.

# 문제

### 문제1 : 논리주소 10번지에 해당 프로세스가 물리 주소 100번지에 올라와 있으면 물리 주소 몇 번지에 접근해야 하나요?

110

### 문제2: 이 그림의 기법은 뭐라고 하나요?

![image.png](image%2013.png)

페이징 기법( FIFO 알고리즘을 이용)
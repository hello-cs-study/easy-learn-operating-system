# 6장 교착상태

# 교착 상태의 정의

교착상태: 2개 이상의 작업이 동시에 이루어지는 경우, 다른 작업이 끝나기만 기다리며 작업을 더 이상 진행하지 못하는 상태

### 철학자 문제

![image.png](image.png)

1. 철학자들은 서로 포크를 공유할 수 없다. → 자원을 공유하지 못하면 교착 상태가 발생
2. 각 철학자는 다른 철학자의 포크를 빼앗을 수 없다. → 자원을 빼앗을 수 없으면 자원을 놓을 때까지 기다려야하므로 교착 상태가 발생
3. 각 철학자는 왼쪽 포크를 잡은 채 오른쪽 포크를 기다린다. → 자원 하나를 잡은 상태에서 다른 자원을 기다리면 교착 상태가 발생
4. 자원 할당 그래프다 원형이다. → 자원을 요구하는 방향이 원을 이루면 양보하지 않기 떄문에 교착 상태가 발생

# 교착 상태 필요조건

- 상호 배제: 한 프로세스가 사용한느 자원은 다른 프로세스와 공유할 수 없는 배타적인 자원이여야 한다.
- 비선점: 한 프로세스가 사용 중인 자원은 중간에 다른 프로세스가 빼앗을 수 없는 비선점 자원이야 한다.
- 점유와 대기: 프로세스는 어떤 자원을 할당받은 상태에서 다른 자원을 기다리는 상태여야 한다.
- 원형 대기: 점유와 대기를 하는 프로세스 간의 관계를 원을 이루어야 한다.

# 교착 상태 해결 방법

- 교착 상태 예방: 교착 상태를 유발하는 네가지 조건이 발생하지 않도록 무력화하는 방식. 상호 배제, 비선점, 점유와 대기, 원형 대기 중 하나라도 막는다면 교착 상태가 발생하지 않기 때문. 하지만 **실효성이 적어 잘 사용되지 않는다.**
    - 상호 배제 예방: 시스템 내에 있는 상호 배타적인 모든 자원, 즉 **독점적으로 사용할 수 있는 자원을 없애버리는 방법. →** 그러나 현실적으로는 모든 자원을 공유할 수 없다.(ex: 예금문제)
    - 비선점 예방: 모든 자원을 빼앗을 수 있도록 만든 방법. → 그러나 임계구역을 보호하기 위해서 잠금을 사용하면 자원을 빼앗을 수 없을 뿐만 아니라 상호 배제 예방도 보장할 수 없다. 또한 **아사현상이 생길 수 있음.**
    - 점유와 대기 예방: 프로세스가 자원을 점유한 상태에서 다른 자원을 기다리지 못하게 하는 방법. → 프로세스가 자신이 사용하는 모든 자원을 자세히 알기 어렵고 자원의 활용성이 떨어짐. 또한 많은 자원을 사용하는 프로세스는 아사 현상이 발생하며 결국 모든 작업이 일괄 작업 방식으로 처리되기 때문에 시스템의 효율이 떨어짐.
    - 밑의 그림을 보면 R1을 쓰기 위해 P2와 P3는 계속 기다려야한다.
    
    ![image.png](image%201.png)
    
    - 원형 대기 예방: 자원을 한 방향으로 사용하도록 설정하여 원형 대기를 예방하는 방식. → 프로세스 작업 진행에 유연성이 떨어지며 자원에 번호를 어떻게 부여할지 문제가 있음. ex) 프린트를 사용한 다음 마우스를 사용할 수 없는 상황.
- 교착 상태 회피: 자원 할당량을 조절하여 교착 상태를 해결하는 방식. 그러나 **자원을 얼마만큼 할당해야 교착 상태가 발생하지 않는다는 보장이 없기 떄문에** 실효성이 적다.
    - 은행원 알고리즘: 대출 금액이 가능한 범위 내이면 대출이 허용되지만 그렇지 않으면 거부되는 것 과 유사. 자신이 사용할 자원 최대 수를 운영체제에게 알려줌.
    
    ![image.png](image%202.png)
    
    - 각 프로세스에 할당된 자원의 수는 ‘할당 자원’에 표시. 프로세스마다 자신이 선언한 최대 자원에서 현재 할당된 자원의 수를 빼면 ‘기대 자원’이 된다. 전체 자원에서 각 프로세스에 할당되고 남은 자원의 수는 ‘가용 자원’이다.
    - 자원 할당 기준
        - 각 프로세스의 기대 자원과 비교하여 가용 자원이 하나라도 크거나 같으면 자원을 할당한다. 가용 자원이 기대 자원보다 크다는 것은 그 자원을 사용하여 작업을 끝낼 수 있는 프로세스가 있다는 의미이므로 안정 상태다.
        - 가용 자원이 어떤 기대 자원보다도 크지 않으면 자원을 할당하지 않는다. 이는 가용 자원을 사용하여 작업을 마칠 수 있는 프로세스가 없다는 이유로 불안정 상태다.
        
        ![image.png](image%203.png)
        
    - 안정 상태: 각 프로세스의 기대 자원과 비교하여 가용 자원이 크거나 같은 경우가 한 번 이상인 경우다. 위는 안정 상태의 그림. (가용 자원을 써서 P2 작업을 마칠 수 있다)
    
    ![image.png](image%204.png)
    
    - 불안정 상태의 상황 ( 가용 자원을 써서 어떤 프로세스도 마칠 수 없다)
    - **교착 상태 회피의 문제점**
        - 프로세스가 자신이 사용할 모든 자원을 미리 선언해야 한다.
        - 시스템의 전체 자원 수가 고정적이어야 한다.
        - 자원이 낭비된다.
- 교착상태 검출: 어떤 제약을 가하지 않고 자원 할당 그래프를 모니터링하면서 교착 상태가 발생하는지 살펴보는 방식. 만약 교착 상태가 발생하면 교착 상태 회복 단계가 진행된다. **가장 현실적인 방법이다.**
    - 타임아웃: 일정 시간 동안 작업이 진행되지 않는 프로세스를 교착 상태가 발생한 것으로 간주하여 처리하는 방법. 하지만 **엉뚱한 프로세스가 강제 종료될 수 있고** **모든 시스템에 적용할 수 없는 문제**가 있다.
    - 자원 할당 그래프를 이용한 교착 상태 검증
- 교착 상태 회복: 만약 교착 상태가 발생하면 교착 상태 회복 단계가 진행된다. **가장 현실적인 방법이다.**
    - 교착 상태를 일으킨 모든 프로세스를 동시에 종료한다. → 이때 **어떤 프로세스를 먼저 실행할 것인지 기준을 정한다.**
    - 교착 상태를 일으킨 프로세스 중 하나를 골라 순서대로 종료한다.
        - 우선순위가 낮은 프로세스를 먼저 종료한다.
        - 우선순위가 같으면 작업 시간이 짧은 프로세스를 먼저 종료한다.
        - 위의 두 조건이 같으면 자원을 많이 사용하는 프로세스를 먼저 종료한다.

![image.png](image%205.png)

교착 상태 회복 단계에서는 관련 프로세스를 강제로 종료하는 일뿐 아니라 강제 동료된 프로세스가 실행되기 전에 시스템을 복구하는 일을 해야 한다. 시스템 복구는 **명령어가 실행될 때마다 체크포인트를 만들어 가장 최근의 검사 시점으로 돌아가는 식**으로 한다. 하지만 작업량이 상당하여 시스템에 부하를 주므로 선택적으로 사용해야 한다.

# 문제

### 문제1 : 은행원 알고리즘 문제에서 이 두가지 상황은 어떤 상태인가?

![image.png](image%206.png)

### 문제2: 이 테스트 코드에 @Transactional은 어떤 역할을 수행하나요?

```java
import static org.assertj.core.api.Assertions.assertThat;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.transaction.annotation.Transactional;

@DataJpaTest  // JPA 테스트를 위한 설정 (내장 DB 사용)
@Transactional // 테스트 후 자동 롤백
class UserRepositoryTest {

    @Autowired
    private UserRepository userRepository;

    @Test
    void testTransactionRollback() {
        // 1. 사용자 추가
        User user = new User(null, "Alice");
        userRepository.save(user);

        // 2. 저장 확인
        assertThat(userRepository.findAll()).hasSize(1);

        // 테스트 종료 후 자동 롤백 -> 데이터가 남아 있지 않음
    }
}
```

Spring의 테스트에서는 **`@Transactional`**을 사용하면 **자동으로 롤백**된다.